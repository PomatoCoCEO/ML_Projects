function [images, classifs] = prepare_images(P, T)
    start = 1;
    end_pos = 29 + start;
    possible_poses = [];
    
    sz = size(P);
    no_features = sz(2); % number of features for more code modularity
    % making an array of the consecutive counts of the same classification
    % for work with convolutional neural networks
    ct = 1;
    cts = [];
    tot_size = 0;
    for i = 2:sz(1)
        if T(i,:) == T(i-1,:)
            ct = ct + 1;
        else
            cts = [cts; [T(i-1,:),ct]];
            tot_size = tot_size + min(ct-no_features+1, 0);
            ct = 1;

        end  
        if i == sz(1)
            cts = [cts; [T(i,:),ct]];
            tot_size = tot_size + min(ct-no_features+1, 0);
        end
    end
    fprintf("counts:");
    disp(cts)
    sz = size(cts);
    images = [];
    classifs = [];
    cummulative = 1;

    % assembling the images
    classifs = zeros(tot_size, no_features, no_features);
    for i = 1 : sz(1)
        element = cts(i,1:4);
        ct = cts(i,5);
        if ct < no_features
            cummulative = cummulative + ct;
            continue;
        end
        for j = 0 : ct - no_features
            arr = P(cummulative + j: cummulative + j+ no_features - 1);
            images = cat(3, images,arr);
            classifs = [classifs; element];
            % will return a 3d array with all the images 
        end
        cummulative = cummulative + ct;
    end

end